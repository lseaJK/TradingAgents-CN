æ–­ç‚¹ç»­ä¼ ï¼ˆcheckpoint/resumeï¼‰åœ¨æ­¤ç±»åˆ†ææµç¨‹é¡¹ç›®ä¸­ï¼Œé€šå¸¸éœ€è¦ï¼š

1. **ä¿å­˜ä¸­é—´çŠ¶æ€**ï¼šåœ¨æ¯ä¸ªå…³é”®æ­¥éª¤æˆ–é˜¶æ®µï¼Œå°†å½“å‰ final_stateï¼ˆæˆ–å…¶ä»–é‡è¦å˜é‡ï¼‰åºåˆ—åŒ–ä¿å­˜åˆ°ç£ç›˜ï¼ˆå¦‚ JSON æ–‡ä»¶ï¼‰ã€‚
2. **å¼‚å¸¸å¤„ç†**ï¼šç”¨ `try...except` æ•è·å¼‚å¸¸ï¼Œé‡åˆ°é”™è¯¯æ—¶è®°å½•æ—¥å¿—ï¼Œå¹¶ä¿å­˜å½“å‰çŠ¶æ€ï¼Œä¾¿äºä¸‹æ¬¡æ¢å¤ã€‚
3. **æ¢å¤æœºåˆ¶**ï¼šå¯åŠ¨æ—¶æ£€æµ‹æ˜¯å¦æœ‰å·²ä¿å­˜çš„ä¸­é—´çŠ¶æ€ï¼Œå¦‚æœæœ‰åˆ™åŠ è½½å¹¶ä»è¯¥çŠ¶æ€ç»§ç»­æ‰§è¡Œã€‚

### å®ç°å»ºè®®

#### 1. ä¿å­˜ä¸­é—´çŠ¶æ€

åœ¨ analyze_and_report çš„å…³é”®æ­¥éª¤ååŠ å…¥ä¿å­˜ï¼š

```python
import json

def save_checkpoint(state, path):

    with open(path, "w", encoding="utf-8") as f:

        json.dump(state, f, ensure_ascii=False, indent=2)

def load_checkpoint(path):

    if Path(path).exists():

        with open(path, "r", encoding="utf-8") as f:

            return json.load(f)

    return None
```

#### 2. å¼‚å¸¸å¤„ç†ä¸æ–­ç‚¹ä¿å­˜

```python
def analyze_and_report(ticker: str, analysis_date: str, debug: bool = True):
    config = DEFAULT_CONFIG.copy()
    results_dir = Path(config["results_dir"]) / ticker / analysis_date
    checkpoint_path = results_dir / "checkpoint.json"
    report_dir = results_dir / "reports"
    results_dir.mkdir(parents=True, exist_ok=True)
    report_dir.mkdir(parents=True, exist_ok=True)

    ta = TradingAgentsGraph(debug=debug, config=config)

    # å°è¯•åŠ è½½æ–­ç‚¹

    final_state = load_checkpoint(checkpoint_path)
    if final_state:
        console.print(Panel("Resuming from checkpoint...", title="Resume", border_style="yellow"))
    try:
        if not final_state:
            final_state, decision = ta.propagate(ticker, analysis_date)
            save_checkpoint(final_state, checkpoint_path)
        else:
            # å¦‚æœæœ‰æ–­ç‚¹ï¼Œç›´æ¥ç”ŸæˆæŠ¥å‘Šå’Œå†³ç­–
            decision = final_state.get("final_trade_decision", "No decision found")
        save_reports(final_state, report_dir)
        display_complete_report(final_state)
        console.print(Panel(Markdown(f"## Final Decision\n\n{decision}"), title="Signal", border_style="green"))
        (results_dir / "decision.txt").write_text(str(decision), encoding="utf-8")
        return decision

    except Exception as e:
        logger.error(f"Error: {e}")
        if final_state:
            save_checkpoint(final_state, checkpoint_path)
        raise
```

#### 3. å¯åŠ¨æ—¶è‡ªåŠ¨æ¢å¤

åªéœ€åœ¨ analyze_and_report å¼€å¤´æ£€æµ‹ checkpoint æ–‡ä»¶å¹¶åŠ è½½å³å¯ã€‚

---

**æ€»ç»“**ï¼š

- æ¯æ­¥ä¿å­˜ final_state åˆ° checkpoint æ–‡ä»¶ã€‚
- å¼‚å¸¸æ—¶è‡ªåŠ¨ä¿å­˜å½“å‰çŠ¶æ€ã€‚
- ä¸‹æ¬¡å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹å¹¶æ¢å¤æ–­ç‚¹ã€‚
- æ—¥å¿—è®°å½•å¼‚å¸¸ï¼Œä¾¿äºæ’æŸ¥ã€‚

å¦‚éœ€æ›´ç»†ç²’åº¦æ–­ç‚¹ï¼Œå¯åœ¨ TradingAgentsGraph å†…éƒ¨å„é˜¶æ®µä¹ŸåŠ å…¥ checkpoint é€»è¾‘ã€‚

### GitHub Copilot

Used 1 reference

ä½ çš„ç†è§£æ˜¯å¯¹çš„ï¼š  
å¦‚æœæ˜¯é€šè¿‡ `graph.stream` æˆ–ç±»ä¼¼æµç¨‹é©±åŠ¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹ï¼ˆagent/stepï¼‰éƒ½å¯èƒ½æœ‰è‡ªå·±çš„çŠ¶æ€å’Œè¾“å‡ºã€‚æ–­ç‚¹ç»­ä¼ è¦å®ç°å¾—ç»†è‡´ï¼Œç¡®å®éœ€è¦**æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰éƒ½åˆ¤æ–­æ˜¯å¦å·²å®Œæˆ**ï¼Œå¹¶èƒ½æ¢å¤åˆ°è¯¥èŠ‚ç‚¹ã€‚

### å®ç°æ€è·¯

1. **èŠ‚ç‚¹çº§çŠ¶æ€ä¿å­˜**
   
   - æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰ï¼Œæ£€æŸ¥æœ¬èŠ‚ç‚¹çš„çŠ¶æ€æ˜¯å¦å·²å­˜åœ¨äº checkpointï¼ˆå¦‚ JSON æ–‡ä»¶ï¼‰ã€‚
   - å¦‚æœå­˜åœ¨ï¼Œè·³è¿‡æ‰§è¡Œï¼Œç›´æ¥ç”¨å·²ä¿å­˜ç»“æœã€‚
   - å¦‚æœä¸å­˜åœ¨ï¼Œæ­£å¸¸æ‰§è¡Œï¼Œå¹¶åœ¨æ‰§è¡Œåä¿å­˜èŠ‚ç‚¹çŠ¶æ€ã€‚

2. **å…¨å±€çŠ¶æ€ç®¡ç†**
   
   - å¯ä»¥è®¾è®¡ä¸€ä¸ª `state_manager`ï¼Œæ¯æ¬¡èŠ‚ç‚¹æ‰§è¡Œåè‡ªåŠ¨ä¿å­˜æ•´ä¸ªæµç¨‹çš„çŠ¶æ€ï¼ˆåŒ…æ‹¬æ¯ä¸ªèŠ‚ç‚¹çš„ç»“æœï¼‰ã€‚
   - æ¢å¤æ—¶ï¼ŒåŠ è½½ checkpointï¼Œæµç¨‹åªæ‰§è¡Œæœªå®Œæˆçš„èŠ‚ç‚¹ã€‚

3. **ä»£ç ç¤ºä¾‹ï¼ˆä¼ªä»£ç ï¼‰**

```python
# åœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰

def run_node(node_name, state, ...):

    checkpoint = load_checkpoint()

    if checkpoint and node_name in checkpoint["completed_nodes"]:

        logger.info(f"Node {node_name} already completed, skipping.")

        return checkpoint["node_results"][node_name]

    # æ­£å¸¸æ‰§è¡Œ

    result = node_execute(...)

    # ä¿å­˜èŠ‚ç‚¹ç»“æœ

    checkpoint["completed_nodes"].append(node_name)

    checkpoint["node_results"][node_name] = result

    save_checkpoint(checkpoint)

    return result
```

### ä½ éœ€è¦åšçš„

- åœ¨ graph/propagation æˆ– agent æ‰§è¡Œé€»è¾‘é‡Œï¼Œ**æ¯ä¸ªèŠ‚ç‚¹å‰éƒ½åŠ æ–­ç‚¹åˆ¤æ–­å’Œä¿å­˜**ã€‚
- å¯ä»¥ç”¨ä¸€ä¸ªå…¨å±€ dict è®°å½•æ‰€æœ‰èŠ‚ç‚¹çš„å®Œæˆæƒ…å†µå’Œç»“æœã€‚
- è¿™æ ·å³ä½¿æµç¨‹ä¸­æ–­ï¼Œä¸‹æ¬¡å¯åŠ¨æ—¶åªéœ€æ¢å¤æœªå®Œæˆçš„èŠ‚ç‚¹ã€‚

---

**æ€»ç»“**ï¼š

- ç†æƒ³åŒ–çš„æ–­ç‚¹ç»­ä¼ ç¡®å®éœ€è¦æ¯ä¸ªèŠ‚ç‚¹éƒ½èƒ½ç‹¬ç«‹åˆ¤æ–­å’Œæ¢å¤ã€‚
- æ¨èåœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰ååŠ  checkpoint é€»è¾‘ã€‚
- è¿™æ ·å¯ä»¥å®ç°çœŸæ­£çš„æµç¨‹çº§æ–­ç‚¹ç»­ä¼ å’Œæ¢å¤ã€‚

è¦åœ¨ä½ çš„ TradingAgents é¡¹ç›®ä¸­å®ç°æ–­ç‚¹ç»­ä¼ ï¼Œå»ºè®®é‡‡ç”¨**èŠ‚ç‚¹çº§æ–­ç‚¹**ï¼Œå³æ¯ä¸ª graph èŠ‚ç‚¹æ‰§è¡Œå‰åéƒ½è¿›è¡ŒçŠ¶æ€æ£€æŸ¥å’Œä¿å­˜ã€‚è¿™æ ·å³ä½¿æµç¨‹ä¸­æ–­ï¼Œä¸‹æ¬¡å¯ä»å·²å®ŒæˆèŠ‚ç‚¹ç»§ç»­ã€‚

#### 1. è®¾è®¡æ–­ç‚¹æ•°æ®ç»“æ„

åœ¨ final_state ä¸­å¢åŠ ä¸€ä¸ª `completed_nodes` å­—å…¸ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ‰§è¡Œç»“æœã€‚ä¾‹å¦‚ï¼š

```
# final_state["completed_nodes"] = {
#     "Market Analyst": {...},
#     "Bull Researcher": {...},
#     ...
# }
```

#### 2. èŠ‚ç‚¹æ‰§è¡Œå‰æ£€æŸ¥æ–­ç‚¹

åœ¨æ¯ä¸ªèŠ‚ç‚¹çš„æ‰§è¡Œé€»è¾‘ï¼ˆå¦‚ agent node æˆ– graph stream handlerï¼‰å‰ï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦å·²å®Œæˆï¼š

```python
def run_node(node_name, state, *args, **kwargs):
    completed = state.get("completed_nodes", {})
    if node_name in completed:
        logger.info(f"æ–­ç‚¹æ¢å¤ï¼š{node_name} å·²å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œã€‚")
        return completed[node_name]  # ç›´æ¥è¿”å›å·²ä¿å­˜ç»“æœ
    result = actual_node_execute(*args, **kwargs)
    completed[node_name] = result
    state["completed_nodes"] = completed
    save_checkpoint(state)  # æ¯æ­¥éƒ½ä¿å­˜
    return result
```

#### 3. ä¿å­˜ä¸åŠ è½½æ–­ç‚¹

åœ¨æ¯æ­¥æ‰§è¡Œåä¿å­˜ final_state åˆ°ç£ç›˜ï¼ˆå¦‚ JSON æ–‡ä»¶ï¼‰ï¼Œå¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½ï¼š

```python
import json

def save_checkpoint(state, path):

    with open(path, "w", encoding="utf-8") as f:

        json.dump(state, f, ensure_ascii=False, indent=2)

def load_checkpoint(path):

    if Path(path).exists():

        with open(path, "r", encoding="utf-8") as f:

            return json.load(f)

    return None
```

#### 4. åœ¨ä¸»æµç¨‹ä¸­é›†æˆæ–­ç‚¹æœºåˆ¶

åœ¨ TradingAgentsGraph.propagate æˆ– graph stream ä¸»å¾ªç¯ä¸­ï¼ŒåŠ è½½æ–­ç‚¹å¹¶åœ¨æ¯ä¸ªèŠ‚ç‚¹å‰åè°ƒç”¨ä¸Šè¿°é€»è¾‘ã€‚

#### 5. é”™è¯¯å¤„ç†

é‡åˆ°å¼‚å¸¸æ—¶ï¼Œè‡ªåŠ¨ä¿å­˜å½“å‰çŠ¶æ€ï¼Œä¾¿äºä¸‹æ¬¡æ¢å¤ã€‚

---

### æ€»ç»“

- **æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰æ£€æŸ¥æ–­ç‚¹ï¼Œå·²å®Œæˆåˆ™è·³è¿‡ã€‚**
- **æ¯æ­¥æ‰§è¡Œåä¿å­˜çŠ¶æ€åˆ° checkpoint æ–‡ä»¶ã€‚**
- **å¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½ checkpointï¼Œæ¢å¤æµç¨‹ã€‚**
- **é‡åˆ°å¼‚å¸¸è‡ªåŠ¨ä¿å­˜æ–­ç‚¹ã€‚**

è¿™æ ·å¯ä»¥å®ç°çœŸæ­£çš„æµç¨‹çº§æ–­ç‚¹ç»­ä¼ ï¼Œæœ€å¤§ç¨‹åº¦å‡å°‘é‡å¤è®¡ç®—å’Œæ•°æ®ä¸¢å¤±ã€‚





# æ¯æ—¥æ¯è‚¡æ–­ç‚¹éš”ç¦»

è¦å°†æ–­ç‚¹ç»­ä¼ æœºåˆ¶åº”ç”¨åˆ°ä½ çš„ TradingAgents é¡¹ç›®ï¼Œå»ºè®®å¦‚ä¸‹ï¼š

### 1. è®¾è®¡æ–­ç‚¹æ•°æ®ç»“æ„

åœ¨ `final_state` å¢åŠ  `completed_nodes` å­—å…¸ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„æ‰§è¡Œç»“æœã€‚

### 2. èŠ‚ç‚¹æ‰§è¡Œå‰æ£€æŸ¥æ–­ç‚¹

åœ¨æ¯ä¸ªèŠ‚ç‚¹çš„ handlerï¼ˆå¦‚ agent node æˆ–å·¥å…· nodeï¼‰å‰ï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦å·²å®Œæˆï¼Œå·²å®Œæˆåˆ™ç›´æ¥è¿”å›ç»“æœï¼Œå¦åˆ™æ­£å¸¸æ‰§è¡Œå¹¶ä¿å­˜ã€‚

### 3. ä¿å­˜ä¸åŠ è½½æ–­ç‚¹

åœ¨æ¯æ­¥æ‰§è¡Œåä¿å­˜ `final_state` åˆ° checkpoint æ–‡ä»¶ï¼Œå¯åŠ¨æ—¶è‡ªåŠ¨åŠ è½½ã€‚

### 4. é›†æˆåˆ° graph stream ä¸»å¾ªç¯

åœ¨ `TradingAgentsGraph.propagate` æˆ– graph stream handler ä¸­ï¼ŒåŠ è½½æ–­ç‚¹å¹¶åœ¨æ¯ä¸ªèŠ‚ç‚¹å‰åè°ƒç”¨ä¸Šè¿°é€»è¾‘ã€‚

å…·ä½“ä»£ç å®ç°å»ºè®®ï¼š

#### a) æ–°å»º checkpoint å·¥å…·å‡½æ•°ï¼ˆå¦‚ tradingagents/utils/checkpoint.pyï¼‰

```python
import json

from pathlib import Path

def save_checkpoint(state, path):

    with open(path, "w", encoding="utf-8") as f:

        json.dump(state, f, ensure_ascii=False, indent=2)

def load_checkpoint(path):

    if Path(path).exists():

        with open(path, "r", encoding="utf-8") as f:

            return json.load(f)

    return None
```

#### b) åœ¨ `TradingAgentsGraph.propagate` æˆ–ä¸»æµç¨‹ä¸­é›†æˆæ–­ç‚¹æœºåˆ¶

æ¯ä¸ªè‚¡ç¥¨ã€æ¯ä¸€å¤©éƒ½è¦æœ‰ç‹¬ç«‹çš„ checkpoint æ–‡ä»¶ï¼Œè·¯å¾„ä¸º  
Path(config["results_dir"]) / ticker / analysis_date / "checkpoint.json"

è¿™æ ·å¯ä»¥å®ç°æ¯æ—¥ã€æ¯è‚¡çš„æ–­ç‚¹éš”ç¦»ï¼Œäº’ä¸å½±å“ã€‚

---

### æ¨èä¿®æ”¹æ–¹æ¡ˆ

åœ¨ TradingAgentsGraph.propagate æ–¹æ³•ä¸­ï¼š

1. ç”¨ self.config["results_dir"]ã€company_nameã€trade_date æ„é€  checkpoint è·¯å¾„ã€‚
2. checkpoint è·¯å¾„ä¸ºï¼š  
   Path(self.config["results_dir"]) / company_name / trade_date / "checkpoint.json"
3. æ–­ç‚¹åŠ è½½ã€ä¿å­˜éƒ½ç”¨è¿™ä¸ªè·¯å¾„ã€‚

```python
    def propagate(self, company_name, trade_date):
        """Run the trading agents graph for a company on a specific date."""

        # æ·»åŠ è¯¦ç»†çš„æ¥æ”¶æ—¥å¿—
        logger.debug(f"ğŸ” [GRAPH DEBUG] ===== TradingAgentsGraph.propagate æ¥æ”¶å‚æ•° =====")
        logger.debug(f"ğŸ” [GRAPH DEBUG] æ¥æ”¶åˆ°çš„company_name: '{company_name}' (ç±»å‹: {type(company_name)})")
        logger.debug(f"ğŸ” [GRAPH DEBUG] æ¥æ”¶åˆ°çš„trade_date: '{trade_date}' (ç±»å‹: {type(trade_date)})")

        self.ticker = company_name
        logger.debug(f"ğŸ” [GRAPH DEBUG] è®¾ç½®self.ticker: '{self.ticker}'")
    
        # è®¾ç½®æ¯æ—¥æ¯è‚¡ç‹¬ç«‹æ–­ç‚¹è·¯å¾„
        checkpoint_dir = Path(self.config["results_dir"]) / company_name / trade_date
        checkpoint_dir.mkdir(parents=True, exist_ok=True)
        checkpoint_path = checkpoint_dir / "checkpoint.json"

        # åŠ è½½ checkpoint æˆ–æ–°å»ºåˆå§‹çŠ¶æ€
        if checkpoint_path.exists():
            with open(checkpoint_path, "r", encoding="utf-8") as f:
                init_agent_state = json.load(f)
            logger.info(f"æ–­ç‚¹æ¢å¤ï¼šå·²åŠ è½½ checkpoint çŠ¶æ€ã€‚")
        else:
            init_agent_state = self.propagator.create_initial_state(company_name, trade_date)
            logger.info(f"æœªå‘ç° checkpointï¼Œä½¿ç”¨æ–°åˆå§‹çŠ¶æ€ã€‚")

        # Initialize state
        logger.debug(f"ğŸ” [GRAPH DEBUG] åˆ›å»ºåˆå§‹çŠ¶æ€ï¼Œä¼ é€’å‚æ•°: company_name='{company_name}', trade_date='{trade_date}'")
        init_agent_state = self.propagator.create_initial_state(
            company_name, trade_date
        )
        logger.debug(f"ğŸ” [GRAPH DEBUG] åˆå§‹çŠ¶æ€ä¸­çš„company_of_interest: '{init_agent_state.get('company_of_interest', 'NOT_FOUND')}'")
        logger.debug(f"ğŸ” [GRAPH DEBUG] åˆå§‹çŠ¶æ€ä¸­çš„trade_date: '{init_agent_state.get('trade_date', 'NOT_FOUND')}'")
        args = self.propagator.get_graph_args()

        try:
            if self.debug:
                trace = []
                for chunk in self.graph.stream(init_agent_state, **args):
                    if len(chunk["messages"]) == 0:
                        pass
                    else:
                        chunk["messages"][-1].pretty_print()
                        # ä¿å­˜ checkpoint
                        with open(checkpoint_path, "w", encoding="utf-8") as f:
                            json.dump(chunk, f, ensure_ascii=False, indent=2, cls=CustomEncoder)
                        trace.append(chunk)
                final_state = trace[-1]
            else:
                final_state = self.graph.invoke(init_agent_state, **args)
                # ä¿å­˜ checkpoint
                with open(checkpoint_path, "w", encoding="utf-8") as f:
                    json.dump(final_state, f, ensure_ascii=False, indent=2)
        except Exception as e:
            # å¼‚å¸¸æ—¶ä¿å­˜å½“å‰çŠ¶æ€
            with open(checkpoint_path, "w", encoding="utf-8") as f:
                json.dump(init_agent_state, f, ensure_ascii=False, indent=2)
            logger.error(f"propagateå¼‚å¸¸: {e}")
            raise 
  
            # Store current state for reflection
        self.curr_state = final_state

        # Log state
        self._log_state(trade_date, final_state)

        # Return decision and processed signal
        return final_state, self.process_signal(final_state["final_trade_decision"], company_name)
```

**æµç¨‹ä¸­æ–­ç‚¹æ¢å¤çš„çŠ¶æ€ä¸€è‡´æ€§**

- å¦‚æœæµç¨‹ä¸­æœ‰å…¶ä»–çŠ¶æ€ï¼ˆå¦‚å†…å­˜ã€æ—¥å¿—ã€ç¼“å­˜ç­‰ï¼‰ï¼Œç¡®ä¿å®ƒä»¬ä¸ checkpoint æ¢å¤æ—¶ä¸€è‡´ã€‚
- æ¯”å¦‚ï¼Œå¦‚æœ final_state é‡Œæœ‰ `completed_nodes` æˆ–å…¶ä»–è¿›åº¦æ ‡è®°ï¼Œå»ºè®®åœ¨ create_initial_state é‡Œä¹Ÿåˆå§‹åŒ–è¿™äº›å­—æ®µã€‚

```python
    def create_initial_state(
        self, company_name: str, trade_date: str
    ) -> Dict[str, Any]:
        """Create the initial state for the agent graph."""
        return {
            "messages": [("human", company_name)],
            "company_of_interest": company_name,
            "trade_date": str(trade_date),
            "investment_debate_state": InvestDebateState(
                {"history": "", "current_response": "", "count": 0}
            ),
            "risk_debate_state": RiskDebateState(
                {
                    "history": "",
                    "current_risky_response": "",
                    "current_safe_response": "",
                    "current_neutral_response": "",
                    "count": 0,
                }
            ),
            "market_report": "",
            "fundamentals_report": "",
            "sentiment_report": "",
            "news_report": "",
            # æ–°å¢æ–­ç‚¹è¿›åº¦å­—æ®µï¼Œä¾¿äºæ–­ç‚¹ç»­ä¼ 
            "completed_nodes": {},
        }

    def get_graph_args(self) -> Dict[str, Any]:
        """Get arguments for the graph invocation."""
        return {
            "stream_mode": "values",
            "config": {"recursion_limit": self.max_recur_limit},
        }


```

chunkå†…å®¹å¦‚ä¸‹ï¼Œç”±äº chunk é‡ŒåŒ…å«äº† `HumanMessage` æˆ–å…¶ä»–è‡ªå®šä¹‰å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡ä¸èƒ½ç›´æ¥è¢« json åºåˆ—åŒ–ã€‚æ‰€ä»¥ç›´æ¥dumpä¼šæŠ¥é”™ï¼Œéœ€è¦åŒ…è£…ä¸€ä¸‹ï¼Œä¿å­˜åˆ°`tradingagents/utils/checkpoints.py`
{'messages': [HumanMessage(content='300476', additional_kwargs={}, response_metadata={}, id='0df1e721-af66-4c39-8060-9bc0cade01d3')], 'company_of_interest': '300476', 'trade_date': '2025-08-20', 'market_report': '', 'sentiment_report': '', 'news_report': '', 'fundamentals_report': '', 'investment_debate_state': {'history': '', 'current_response': '', 'count': 0}, 'risk_debate_state': {'history': '', 'current_risky_response': '', 'current_safe_response': '', 'current_neutral_response': '', 'count': 0}}

```python
import json
from pathlib import Path

def save_checkpoint(state, path):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)

def load_checkpoint(path):
    if Path(path).exists():
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    r
eturn None

# ä¸èƒ½åºåˆ—åŒ–å†…å®¹åŒ…è£…
class CustomEncoder(json.JSONEncoder):
    def default(self, obj):
        if hasattr(obj, 'dict'):
            return obj.dict()
        if hasattr(obj, '__dict__'):
            return obj.__dict__
        return str(obj)
# ç”¨æ³•
# json.dump(chunk, f, ensure_ascii=False, indent=2, cls=CustomEncoder)
```

**èŠ‚ç‚¹æ˜¯å¦å·²æ‰§è¡Œçš„åˆ¤æ–­å’Œè·³è¿‡é€»è¾‘**è¿˜æ²¡æœ‰åœ¨ä¸»æµç¨‹æˆ–èŠ‚ç‚¹æ‰§è¡Œå¤„å®ç°ã€‚

ä½ éœ€è¦åšä»€ä¹ˆï¼Ÿ

1. **åœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰ï¼Œåˆ¤æ–­ completed_nodes æ˜¯å¦å·²åŒ…å«è¯¥èŠ‚ç‚¹ç»“æœ**
   
   - å¦‚æœå·²å®Œæˆï¼Œåˆ™ç›´æ¥è·³è¿‡è¯¥èŠ‚ç‚¹æˆ–è¿”å›å·²ä¿å­˜ç»“æœã€‚
   - å¦‚æœæœªå®Œæˆï¼Œåˆ™æ­£å¸¸æ‰§è¡Œï¼Œå¹¶åœ¨æ‰§è¡Œåä¿å­˜ç»“æœåˆ° completed_nodesã€‚

2. **æ¨èå®ç°ä½ç½®**
   
   - å¦‚æœä½ æœ‰èŠ‚ç‚¹æ‰§è¡Œçš„ç»Ÿä¸€å…¥å£ï¼ˆå¦‚ `run_node` æˆ– graph handlerï¼‰ï¼Œå°±åœ¨è¿™é‡ŒåŠ åˆ¤æ–­ã€‚
   - å¦‚æœæ˜¯ langgraph/StateGraph è‡ªåŠ¨è°ƒåº¦èŠ‚ç‚¹ï¼Œå¯ä»¥åœ¨æ¯ä¸ª node handler é‡ŒåŠ åˆ¤æ–­ã€‚

ç¤ºä¾‹ä»£ç ï¼ˆä¼ªä»£ç ï¼‰

å‡è®¾ä½ æœ‰å¦‚ä¸‹èŠ‚ç‚¹æ‰§è¡Œé€»è¾‘ï¼š

```python
def run_node(node_name, state, *args, **kwargs):
    completed = state.get("completed_nodes", {})
    if node_name in completed:
        logger.info(f"æ–­ç‚¹æ¢å¤ï¼š{node_name} å·²å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œã€‚")
        return completed[node_name]  # ç›´æ¥è¿”å›å·²ä¿å­˜ç»“æœ
    result = actual_node_execute(node_name, state, *args, **kwargs)
    completed[node_name] = result
    state["completed_nodes"] = completed
    # ä¿å­˜ checkpoint
    save_checkpoint(state)
    return result
```

é›†æˆåˆ°ä½ çš„é¡¹ç›®

- åœ¨æ¯ä¸ªèŠ‚ç‚¹ handler æˆ– graph æ‰§è¡Œå…¥å£åŠ å¦‚ä¸Šåˆ¤æ–­ã€‚
- è¿™æ ·ï¼Œæ–­ç‚¹æ¢å¤æ—¶ä¼šè‡ªåŠ¨è·³è¿‡å·²å®ŒæˆèŠ‚ç‚¹ï¼Œåªæ‰§è¡Œæœªå®Œæˆéƒ¨åˆ†ã€‚

---

**æ€»ç»“**ï¼š  
ä½ å·²ç»å®ç°äº†èŠ‚ç‚¹çŠ¶æ€ä¿å­˜ï¼Œä½†è¿˜éœ€åœ¨èŠ‚ç‚¹æ‰§è¡Œå…¥å£åŠ â€œæ˜¯å¦å·²å®Œæˆâ€åˆ¤æ–­å’Œè·³è¿‡é€»è¾‘ï¼Œæ‰èƒ½å®ç°çœŸæ­£çš„æ–­ç‚¹ç»­ä¼ ã€‚  

1ï¼‰**åœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå‰ï¼Œåˆ¤æ–­ completed_nodes æ˜¯å¦å·²åŒ…å«è¯¥èŠ‚ç‚¹ç»“æœ**

- å¦‚æœå·²å®Œæˆï¼Œåˆ™ç›´æ¥è·³è¿‡è¯¥èŠ‚ç‚¹æˆ–è¿”å›å·²ä¿å­˜ç»“æœã€‚
- å¦‚æœæœªå®Œæˆï¼Œåˆ™æ­£å¸¸æ‰§è¡Œï¼Œå¹¶åœ¨æ‰§è¡Œåä¿å­˜ç»“æœåˆ° completed_nodesã€‚

**æ¨èå®ç°ä½ç½®**

- å¦‚æœä½ æœ‰èŠ‚ç‚¹æ‰§è¡Œçš„ç»Ÿä¸€å…¥å£ï¼ˆå¦‚ `run_node` æˆ– graph handlerï¼‰ï¼Œå°±åœ¨è¿™é‡ŒåŠ åˆ¤æ–­ã€‚
- å¦‚æœæ˜¯ langgraph/StateGraph è‡ªåŠ¨è°ƒåº¦èŠ‚ç‚¹ï¼Œå¯ä»¥åœ¨æ¯ä¸ª node handler é‡ŒåŠ åˆ¤æ–­ã€‚

2ï¼‰ToolNode ä¸æ˜¯ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼ˆä¸æ˜¯å‡½æ•°ï¼‰ï¼Œè€Œæ˜¯ä¸€ä¸ªç±»å®ä¾‹ï¼Œä¸èƒ½åƒå‡½æ•°ä¸€æ ·ç›´æ¥è°ƒç”¨ã€‚

å¦‚æœ ToolNode ä¸èƒ½åŒ…è£…æ–­ç‚¹é€»è¾‘ï¼Œé‚£ä¹ˆåœ¨ workflow çš„è¾¹ï¼ˆedgeï¼‰é€‰æ‹©æ—¶ï¼Œåº”è¯¥æ ¹æ® `completed_nodes` åˆ¤æ–­æ˜¯å¦è·³è¿‡ tool_nodeï¼Œç›´æ¥æµå‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

**æ¨èå®ç°æ–¹å¼**ï¼šåœ¨ conditional_edges çš„æ¡ä»¶å‡½æ•°é‡ŒåŠ åˆ¤æ–­

- è®©æ¡ä»¶å‡½æ•°ï¼ˆå¦‚ `should_continue_market`ï¼‰æ£€æŸ¥ state["completed_nodes"] æ˜¯å¦å·²åŒ…å« tool_node æˆ–å½“å‰èŠ‚ç‚¹ç»“æœã€‚
- å¦‚æœå·²å®Œæˆï¼Œåˆ™ç›´æ¥è¿”å›ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå¦‚ clear/msg/ä¸‹ä¸€ä¸ª analystï¼‰ï¼Œå¦åˆ™æ­£å¸¸æµå‘ tool_nodeã€‚
  
  

åŸæ¥çš„marketåˆ°toolå’ŒclearèŠ‚ç‚¹å·²ç»æ˜¯æ¡ä»¶è¾¹äº†ï¼Œæ‰€ä»¥ç°åœ¨åªéœ€è¦å¢åŠ æ¡ä»¶åˆ¤æ–­çš„é€»è¾‘å³å¯ã€‚ä¿®æ”¹åŸå…ˆçš„å››ä¸ªåˆ†æå¸ˆæ¡ä»¶ä»£ç å³å¯ã€‚

```python
# TradingAgents/graph/conditional_logic.py
    def should_continue_market(self, state: AgentState):
        """Determine if market analysis should continue."""
        # æ–­ç‚¹ç»­ä¼ ï¼šå¦‚æœtools_marketå·²å®Œæˆåˆ™ç›´æ¥è·³è¿‡
        if "tools_market" in state.get("completed_nodes", {}):
            return "Msg Clear Market"
        messages = state["messages"]
        last_message = messages[-1]
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            return "tools_market"
        return "Msg Clear Market"

    def should_continue_social(self, state: AgentState):
        """Determine if social media analysis should continue."""
        if "tools_social" in state.get("completed_nodes", {}):
            return "Msg Clear Social"
        messages = state["messages"]
        last_message = messages[-1]
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            return "tools_social"
        return "Msg Clear Social"

    def should_continue_news(self, state: AgentState):
        """Determine if news analysis should continue."""
        if "tools_news" in state.get("completed_nodes", {}):
            return "Msg Clear News"
        messages = state["messages"]
        last_message = messages[-1]
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            return "tools_news"
        return "Msg Clear News"

    def should_continue_fundamentals(self, state: AgentState):
        """Determine if fundamentals analysis should continue."""
        if "tools_fundamentals" in state.get("completed_nodes", {}):
            return "Msg Clear Fundamentals"
        messages = state["messages"]
        last_message = messages[-1]
        if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
            return "tools_fundamentals"
        return "Msg Clear Fundamentals"
```

```python
# TradingAgents/graph/setup.py

from typing import Dict, Any
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph, START
from langgraph.prebuilt import ToolNode

from tradingagents.agents import *
from tradingagents.agents.utils.agent_states import AgentState
from tradingagents.agents.utils.agent_utils import Toolkit

from .conditional_logic import ConditionalLogic

# å¯¼å…¥ç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿ
from tradingagents.utils.logging_init import get_logger
logger = get_logger("default")


# èŠ‚ç‚¹æ‰§è¡Œæ–­ç‚¹ç»­ä¼ é€»è¾‘
def node_with_checkpoint(node_name, node_func):
    def wrapper(state, *args, **kwargs):
        completed = state.get("completed_nodes", {})
        if node_name in completed:
            logger.info(f"æ–­ç‚¹æ¢å¤ï¼š{node_name} å·²å®Œæˆï¼Œè·³è¿‡æ‰§è¡Œã€‚")
            return completed[node_name]
        result = node_func(state, *args, **kwargs)
        completed[node_name] = result
        state["completed_nodes"] = completed
        return result
    return wrapper

class GraphSetup:
    """Handles the setup and configuration of the agent graph."""

    def __init__(
        self,
        quick_thinking_llm: ChatOpenAI,
        deep_thinking_llm: ChatOpenAI,
        toolkit: Toolkit,
        tool_nodes: Dict[str, ToolNode],
        bull_memory,
        bear_memory,
        trader_memory,
        invest_judge_memory,
        risk_manager_memory,
        conditional_logic: ConditionalLogic,
        config: Dict[str, Any] = None,
        react_llm = None,
    ):
        """Initialize with required components."""
        self.quick_thinking_llm = quick_thinking_llm
        self.deep_thinking_llm = deep_thinking_llm
        self.toolkit = toolkit
        self.tool_nodes = tool_nodes
        self.bull_memory = bull_memory
        self.bear_memory = bear_memory
        self.trader_memory = trader_memory
        self.invest_judge_memory = invest_judge_memory
        self.risk_manager_memory = risk_manager_memory
        self.conditional_logic = conditional_logic
        self.config = config or {}
        self.react_llm = react_llm


    def setup_graph(
        self, selected_analysts=["market", "social", "news", "fundamentals"]
    ):
        """Set up and compile the agent workflow graph.

        Args:
            selected_analysts (list): List of analyst types to include. Options are:
                - "market": Market analyst
                - "social": Social media analyst
                - "news": News analyst
                - "fundamentals": Fundamentals analyst
        """
        if len(selected_analysts) == 0:
            raise ValueError("Trading Agents Graph Setup Error: no analysts selected!")

        # Create analyst nodes
        analyst_nodes = {}
        delete_nodes = {}
        tool_nodes = {}

        if "market" in selected_analysts:
            # ç°åœ¨æ‰€æœ‰LLMéƒ½ä½¿ç”¨æ ‡å‡†å¸‚åœºåˆ†æå¸ˆï¼ˆåŒ…æ‹¬é˜¿é‡Œç™¾ç‚¼çš„OpenAIå…¼å®¹é€‚é…å™¨ï¼‰
            llm_provider = self.config.get("llm_provider", "").lower()

            # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨OpenAIå…¼å®¹çš„é˜¿é‡Œç™¾ç‚¼é€‚é…å™¨
            using_dashscope_openai = (
                "dashscope" in llm_provider and
                hasattr(self.quick_thinking_llm, '__class__') and
                'OpenAI' in self.quick_thinking_llm.__class__.__name__
            )

            if using_dashscope_openai:
                logger.debug(f"ğŸ“ˆ [DEBUG] ä½¿ç”¨æ ‡å‡†å¸‚åœºåˆ†æå¸ˆï¼ˆé˜¿é‡Œç™¾ç‚¼OpenAIå…¼å®¹æ¨¡å¼ï¼‰")
            elif "dashscope" in llm_provider or "é˜¿é‡Œç™¾ç‚¼" in self.config.get("llm_provider", ""):
                logger.debug(f"ğŸ“ˆ [DEBUG] ä½¿ç”¨æ ‡å‡†å¸‚åœºåˆ†æå¸ˆï¼ˆé˜¿é‡Œç™¾ç‚¼åŸç”Ÿæ¨¡å¼ï¼‰")
            elif "deepseek" in llm_provider:
                logger.debug(f"ğŸ“ˆ [DEBUG] ä½¿ç”¨æ ‡å‡†å¸‚åœºåˆ†æå¸ˆï¼ˆDeepSeekï¼‰")
            else:
                logger.debug(f"ğŸ“ˆ [DEBUG] ä½¿ç”¨æ ‡å‡†å¸‚åœºåˆ†æå¸ˆ")

            # æ‰€æœ‰LLMéƒ½ä½¿ç”¨æ ‡å‡†åˆ†æå¸ˆ
            analyst_nodes["market"] = create_market_analyst(
                self.quick_thinking_llm, self.toolkit
            )
            delete_nodes["market"] = create_msg_delete()
            tool_nodes["market"] = self.tool_nodes["market"]

        if "social" in selected_analysts:
            analyst_nodes["social"] = create_social_media_analyst(
                self.quick_thinking_llm, self.toolkit
            )
            delete_nodes["social"] = create_msg_delete()
            tool_nodes["social"] = self.tool_nodes["social"]

        if "news" in selected_analysts:
            analyst_nodes["news"] = create_news_analyst(
                self.quick_thinking_llm, self.toolkit
            )
            delete_nodes["news"] = create_msg_delete()
            tool_nodes["news"] = self.tool_nodes["news"]

        if "fundamentals" in selected_analysts:
            # ç°åœ¨æ‰€æœ‰LLMéƒ½ä½¿ç”¨æ ‡å‡†åŸºæœ¬é¢åˆ†æå¸ˆï¼ˆåŒ…æ‹¬é˜¿é‡Œç™¾ç‚¼çš„OpenAIå…¼å®¹é€‚é…å™¨ï¼‰
            llm_provider = self.config.get("llm_provider", "").lower()

            # æ£€æŸ¥æ˜¯å¦ä½¿ç”¨OpenAIå…¼å®¹çš„é˜¿é‡Œç™¾ç‚¼é€‚é…å™¨
            using_dashscope_openai = (
                "dashscope" in llm_provider and
                hasattr(self.quick_thinking_llm, '__class__') and
                'OpenAI' in self.quick_thinking_llm.__class__.__name__
            )

            if using_dashscope_openai:
                logger.debug(f"ğŸ“Š [DEBUG] ä½¿ç”¨æ ‡å‡†åŸºæœ¬é¢åˆ†æå¸ˆï¼ˆé˜¿é‡Œç™¾ç‚¼OpenAIå…¼å®¹æ¨¡å¼ï¼‰")
            elif "dashscope" in llm_provider or "é˜¿é‡Œç™¾ç‚¼" in self.config.get("llm_provider", ""):
                logger.debug(f"ğŸ“Š [DEBUG] ä½¿ç”¨æ ‡å‡†åŸºæœ¬é¢åˆ†æå¸ˆï¼ˆé˜¿é‡Œç™¾ç‚¼åŸç”Ÿæ¨¡å¼ï¼‰")
            elif "deepseek" in llm_provider:
                logger.debug(f"ğŸ“Š [DEBUG] ä½¿ç”¨æ ‡å‡†åŸºæœ¬é¢åˆ†æå¸ˆï¼ˆDeepSeekï¼‰")
            else:
                logger.debug(f"ğŸ“Š [DEBUG] ä½¿ç”¨æ ‡å‡†åŸºæœ¬é¢åˆ†æå¸ˆ")

            # æ‰€æœ‰LLMéƒ½ä½¿ç”¨æ ‡å‡†åˆ†æå¸ˆï¼ˆåŒ…å«å¼ºåˆ¶å·¥å…·è°ƒç”¨æœºåˆ¶ï¼‰
            analyst_nodes["fundamentals"] = create_fundamentals_analyst(
                self.quick_thinking_llm, self.toolkit
            )
            delete_nodes["fundamentals"] = create_msg_delete()
            tool_nodes["fundamentals"] = self.tool_nodes["fundamentals"]

        # Create researcher and manager nodes
        bull_researcher_node = create_bull_researcher(
            self.quick_thinking_llm, self.bull_memory
        )
        bear_researcher_node = create_bear_researcher(
            self.quick_thinking_llm, self.bear_memory
        )
        research_manager_node = create_research_manager(
            self.deep_thinking_llm, self.invest_judge_memory
        )
        trader_node = create_trader(self.quick_thinking_llm, self.trader_memory)

        # Create risk analysis nodes
        risky_analyst = create_risky_debator(self.quick_thinking_llm)
        neutral_analyst = create_neutral_debator(self.quick_thinking_llm)
        safe_analyst = create_safe_debator(self.quick_thinking_llm)
        risk_manager_node = create_risk_manager(
            self.deep_thinking_llm, self.risk_manager_memory
        )

        # Create workflow
        workflow = StateGraph(AgentState)

        # åŒ…è£…æ‰€æœ‰ analyst/researcher/manager/risk/trader èŠ‚ç‚¹
        for analyst_type, node in analyst_nodes.items():
            workflow.add_node(f"{analyst_type.capitalize()} Analyst", node_with_checkpoint(f"{analyst_type.capitalize()} Analyst", node))
            workflow.add_node(
                f"Msg Clear {analyst_type.capitalize()}", node_with_checkpoint(f"Msg Clear {analyst_type.capitalize()}", delete_nodes[analyst_type])
            )
            workflow.add_node(f"tools_{analyst_type}", node_with_checkpoint(f"tools_{analyst_type}", tool_nodes[analyst_type]))


        workflow.add_node("Bull Researcher", node_with_checkpoint("Bull Researcher", bull_researcher_node))
        workflow.add_node("Bear Researcher", node_with_checkpoint("Bear Researcher", bear_researcher_node))
        workflow.add_node("Research Manager", node_with_checkpoint("Research Manager", research_manager_node))
        workflow.add_node("Trader", node_with_checkpoint("Trader", trader_node))
        workflow.add_node("Risky Analyst", node_with_checkpoint("Risky Analyst", risky_analyst))
        workflow.add_node("Neutral Analyst", node_with_checkpoint("Neutral Analyst", neutral_analyst))
        workflow.add_node("Safe Analyst", node_with_checkpoint("Safe Analyst", safe_analyst))
        workflow.add_node("Risk Judge", node_with_checkpoint("Risk Judge", risk_manager_node))

        # Define edges
        # Start with the first analyst
        first_analyst = selected_analysts[0]
        workflow.add_edge(START, f"{first_analyst.capitalize()} Analyst")

        # Connect analysts in sequence
        for i, analyst_type in enumerate(selected_analysts):
            current_analyst = f"{analyst_type.capitalize()} Analyst"
            current_tools = f"tools_{analyst_type}"
            current_clear = f"Msg Clear {analyst_type.capitalize()}"

            # Add conditional edges for current analyst
            workflow.add_conditional_edges(
                current_analyst,
                getattr(self.conditional_logic, f"should_continue_{analyst_type}"),
                [current_tools, current_clear],
            )
            workflow.add_edge(current_tools, current_analyst)

            # Connect to next analyst or to Bull Researcher if this is the last analyst
            if i < len(selected_analysts) - 1:
                next_analyst = f"{selected_analysts[i+1].capitalize()} Analyst"
                workflow.add_edge(current_clear, next_analyst)
            else:
                workflow.add_edge(current_clear, "Bull Researcher")

        # Add remaining edges
        workflow.add_conditional_edges(
            "Bull Researcher",
            self.conditional_logic.should_continue_debate,
            {
                "Bear Researcher": "Bear Researcher",
                "Research Manager": "Research Manager",
            },
        )
        workflow.add_conditional_edges(
            "Bear Researcher",
            self.conditional_logic.should_continue_debate,
            {
                "Bull Researcher": "Bull Researcher",
                "Research Manager": "Research Manager",
            },
        )
        workflow.add_edge("Research Manager", "Trader")
        workflow.add_edge("Trader", "Risky Analyst")
        workflow.add_conditional_edges(
            "Risky Analyst",
            self.conditional_logic.should_continue_risk_analysis,
            {
                "Safe Analyst": "Safe Analyst",
                "Risk Judge": "Risk Judge",
            },
        )
        workflow.add_conditional_edges(
            "Safe Analyst",
            self.conditional_logic.should_continue_risk_analysis,
            {
                "Neutral Analyst": "Neutral Analyst",
                "Risk Judge": "Risk Judge",
            },
        )
        workflow.add_conditional_edges(
            "Neutral Analyst",
            self.conditional_logic.should_continue_risk_analysis,
            {
                "Risky Analyst": "Risky Analyst",
                "Risk Judge": "Risk Judge",
            },
        )

        workflow.add_edge("Risk Judge", END)

        # Compile and return
        return workflow.compile()


```